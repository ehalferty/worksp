//------------------------------------------------------------------------------
//
// Copyright (C) 2006, Xilinx, Inc. All Rights Reserved.
//
// This file is owned and controlled by Xilinx and must be used solely
// for design, simulation, implementation and creation of design files
// limited to Xilinx devices or technologies. Use with non-Xilinx
// devices or technologies is expressly prohibited and immediately
// terminates your license.
//
// Xilinx products are not intended for use in life support
// appliances, devices, or systems. Use in such applications is
// expressly prohibited.
//
//   ____  ____
//  /   /\/   /
// /___/  \  /    Vendor      : Xilinx
// \   \   \/     Version     : 1.3
//  \   \         Application : Generated by Xilinx PCI Express Wizard
//  /   /         Filename    : pcie_blk_cf_mgmt.v
// /___/   /\     Module      : pcie_blk_cf_mgmt
// \   \  /  \
//  \___\/\___\
//
//
// Description: Management Interface. This module will poll the
// configuration registers to store in shadow registers, and it will also
// arbitrate for access to the management interface with the user.
//
//--------------------------------------------------------------------------------

`timescale 1ns/1ns

`ifndef Tcq
    `define Tcq 0 
`endif

`define INSTANTIATE_LUTROM 1

module pcie_blk_cf_mgmt
(
       // PCIe Block clock and reset

       input wire         clk,
       input wire         rst_n,

       // PCIe CFG signals
       input wire  [12:0] completer_id,

       // PCIe Block Management Interface

       output reg  [10:0] mgmt_addr   , //= 11'h047,
       output reg         mgmt_wren   , //= 0,
       output reg         mgmt_rden   , //= 0,
       output reg  [31:0] mgmt_wdata  , //= 0,
       output reg   [3:0] mgmt_bwren  , //= 0,

       input  wire [31:0] mgmt_rdata,
 
       // PCIe Soft Macro Cfg Interface
       
       input  wire [63:0] cfg_dsn,
       output reg  [31:0] cfg_do         , //= 0,
       output reg         cfg_write_done , //= 1,
       output wire        cfg_read_done,
       input  wire [10:0] cfg_dwaddr,
       input  wire        cfg_rd_en_n,
       input  wire        cfg_wr_en_n,
       input  wire  [3:0] cfg_byte_en,
       input  wire [31:0] cfg_wr_data,
       output reg  [31:0] cfg_rx_bar0  , //= 0,
       output reg  [31:0] cfg_rx_bar1  , //= 0,
       output reg  [31:0] cfg_rx_bar2  , //= 0,
       output reg  [31:0] cfg_rx_bar3  , //= 0,
       output reg  [31:0] cfg_rx_bar4  , //= 0,
       output reg  [31:0] cfg_rx_bar5  , //= 0,
       output reg  [31:0] cfg_rx_xrom  , //= 0,
       output reg  [15:0] cfg_status   , //= 0,
       output reg  [15:0] cfg_command  , //= 0,
       output reg  [15:0] cfg_dstatus  , //= 0,
       output reg  [15:0] cfg_dcommand , //= 0,
       output reg  [15:0] cfg_lstatus  , //= 0,
       output reg  [15:0] cfg_lcommand , //= 0,
       output reg  [31:0] cfg_pmcsr    , //= 0,
       output reg  [31:0] cfg_dcap     , //= 0,
       output wire  [7:0] cfg_bus_number,
       output wire  [4:0] cfg_device_number,
       output wire  [2:0] cfg_function_number

); 


    (* ram_style = "distributed" *)
    reg  [6:0] poll_dwaddr_rom [0:15];
    reg [15:0] poll_dwrw_rom;
    reg  [3:0] poll_dwaddr_cntr    = 0;
    reg  [3:0] poll_dwaddr_cntr_d1 = 0;
    reg  [3:0] poll_dwaddr_cntr_d2 = 0;
    reg        poll_en             = 0;
    reg        poll_data_en_d      = 0;
    reg        wait_stg1           = 0;
    reg        wait_stg2           = 0;
    reg [31:0] mgmt_rdata_d1       = 0;
    reg        lock_useraccess     = 0;
    wire       poll_data_en;
    
    reg       cfg_rd_en_n_hold;
    reg       cfg_wr_en_n_hold;
    reg       cfg_rd_wr_done_n = 1;
    
    assign cfg_bus_number      = completer_id[12:5];
    assign cfg_device_number   = completer_id[4:0];
    assign cfg_function_number = 3'b000;
    
    `ifndef INSTANTIATE_LUTROM
    // A ROM to store the sequence of addresses to poll
    initial begin
       poll_dwaddr_rom[0]   = 7'h47;
       poll_dwaddr_rom[1]   = 7'h48;
       poll_dwaddr_rom[2]   = 7'h01;
       poll_dwaddr_rom[3]   = 7'h04;
       poll_dwaddr_rom[4]   = 7'h05;
       poll_dwaddr_rom[5]   = 7'h06;
       poll_dwaddr_rom[6]   = 7'h07;
       poll_dwaddr_rom[7]   = 7'h08;
       poll_dwaddr_rom[8]   = 7'h09;
       poll_dwaddr_rom[9]   = 7'h0c;
       poll_dwaddr_rom[10]  = 7'h2a;
       poll_dwaddr_rom[11]  = 7'h2c;
       poll_dwaddr_rom[12]  = 7'h1e;
       poll_dwaddr_rom[13]  = 7'h29;
       poll_dwaddr_rom[14]  = 7'h47;
       poll_dwaddr_rom[15]  = 7'h48;
    end
    
    // A ROM to store the sequence of read or write ops
    initial begin
       poll_dwrw_rom[0]   = 1'b0;
       poll_dwrw_rom[1]   = 1'b0;
       poll_dwrw_rom[2]   = 1'b0;
       poll_dwrw_rom[3]   = 1'b0;
       poll_dwrw_rom[4]   = 1'b0;
       poll_dwrw_rom[5]   = 1'b0;
       poll_dwrw_rom[6]   = 1'b0;
       poll_dwrw_rom[7]   = 1'b0;
       poll_dwrw_rom[8]   = 1'b0;
       poll_dwrw_rom[9]   = 1'b0;
       poll_dwrw_rom[10]  = 1'b0;
       poll_dwrw_rom[11]  = 1'b0;
       poll_dwrw_rom[12]  = 1'b0;
       poll_dwrw_rom[13]  = 1'b0;
       poll_dwrw_rom[14]  = 1'b1;
       poll_dwrw_rom[15]  = 1'b1;
    end
    
    wire [10:0] poll_dwaddr  = {4'b0,poll_dwaddr_rom[poll_dwaddr_cntr]};
    wire        poll_dwrw    = poll_dwrw_rom[poll_dwaddr_cntr];
    
    `else
    
    wire  [6:0] poll_dwaddrx;
    wire        poll_dwrw;
    
    //// DWADDR LUT ROM ////
    //               fedc ba98 7654 3210
    LUT4 #(.INIT(16'b0110_0001_0101_0101)) lut_dwaddr_rom0( .O (poll_dwaddrx[0]), .I0(poll_dwaddr_cntr[0]), .I1(poll_dwaddr_cntr[1]), .I2(poll_dwaddr_cntr[2]), .I3(poll_dwaddr_cntr[3]));
    //               fedc ba98 7654 3210
    LUT4 #(.INIT(16'b0101_0100_0110_0001)) lut_dwaddr_rom1( .O (poll_dwaddrx[1]), .I0(poll_dwaddr_cntr[0]), .I1(poll_dwaddr_cntr[1]), .I2(poll_dwaddr_cntr[2]), .I3(poll_dwaddr_cntr[3]));
    //               fedc ba98 7654 3210
    LUT4 #(.INIT(16'b0101_1010_0111_1001)) lut_dwaddr_rom2( .O (poll_dwaddrx[2]), .I0(poll_dwaddr_cntr[0]), .I1(poll_dwaddr_cntr[1]), .I2(poll_dwaddr_cntr[2]), .I3(poll_dwaddr_cntr[3]));
    //               fedc ba98 7654 3210
    LUT4 #(.INIT(16'b1011_1111_1000_0010)) lut_dwaddr_rom3( .O (poll_dwaddrx[3]), .I0(poll_dwaddr_cntr[0]), .I1(poll_dwaddr_cntr[1]), .I2(poll_dwaddr_cntr[2]), .I3(poll_dwaddr_cntr[3]));
    //               fedc ba98 7654 3210
    LUT4 #(.INIT(16'b0001_0000_0000_0000)) lut_dwaddr_rom4( .O (poll_dwaddrx[4]), .I0(poll_dwaddr_cntr[0]), .I1(poll_dwaddr_cntr[1]), .I2(poll_dwaddr_cntr[2]), .I3(poll_dwaddr_cntr[3]));
    //               fedc ba98 7654 3210
    LUT4 #(.INIT(16'b0010_1100_0000_0000)) lut_dwaddr_rom5( .O (poll_dwaddrx[5]), .I0(poll_dwaddr_cntr[0]), .I1(poll_dwaddr_cntr[1]), .I2(poll_dwaddr_cntr[2]), .I3(poll_dwaddr_cntr[3]));
    //               fedc ba98 7654 3210
    LUT4 #(.INIT(16'b1100_0000_0000_0011)) lut_dwaddr_rom6( .O (poll_dwaddrx[6]), .I0(poll_dwaddr_cntr[0]), .I1(poll_dwaddr_cntr[1]), .I2(poll_dwaddr_cntr[2]), .I3(poll_dwaddr_cntr[3]));
    
    wire [10:0] poll_dwaddr  = {4'b0,poll_dwaddrx};
    
    //// DWRW LUT ROM ////
    //               fedc ba98 7654 3210
    LUT4 #(.INIT(16'b1100_0000_0000_0000)) lut_dwrw_rom( .O (poll_dwrw), .I0(poll_dwaddr_cntr[0]), .I1(poll_dwaddr_cntr[1]), .I2(poll_dwaddr_cntr[2]), .I3(poll_dwaddr_cntr[3]));
    
    
    `endif
    
    wire enable_mgmt_op = (~mgmt_rden && ~wait_stg1 && ~lock_useraccess);
    
    
    always @(posedge clk)
    begin
        if (cfg_rd_en_n == 1'b0 && enable_mgmt_op == 1'b0)
            cfg_rd_en_n_hold <= #`Tcq cfg_rd_en_n;
        else if (cfg_rd_en_n_hold == 1'b0 && enable_mgmt_op == 1'b0)
            cfg_rd_en_n_hold <= #`Tcq cfg_rd_en_n_hold;
        else
            cfg_rd_en_n_hold <= #`Tcq 1'b1;
            
    end        
        
    
    
    always @(posedge clk)
    begin
        if (cfg_wr_en_n == 1'b0 && enable_mgmt_op == 1'b0)
            cfg_wr_en_n_hold <= #`Tcq cfg_wr_en_n;
        else if (cfg_wr_en_n_hold == 1'b0 && enable_mgmt_op == 1'b0)
            cfg_wr_en_n_hold <= #`Tcq cfg_wr_en_n_hold;
        else
            cfg_wr_en_n_hold <= #`Tcq 1'b1;
            
    end 
    
    // Generate MGMT interface transaction
    always @(posedge clk) begin
       if (~rst_n) begin
          mgmt_addr           <= #`Tcq 11'h047;
          mgmt_wdata          <= #`Tcq 0;
          mgmt_bwren          <= #`Tcq 0;
          mgmt_rden           <= #`Tcq 0;
          mgmt_wren           <= #`Tcq 0;
          poll_en             <= #`Tcq 0;
          poll_dwaddr_cntr    <= #`Tcq 0;
          poll_dwaddr_cntr_d1 <= #`Tcq 0;
          cfg_write_done      <= #`Tcq 1'b0;
       end else if (enable_mgmt_op) begin
          // user requests Configuration access
          if (~cfg_rd_en_n || ~cfg_rd_en_n_hold ) begin
             mgmt_addr           <= #`Tcq cfg_dwaddr;
             mgmt_rden           <= #`Tcq 1;
             mgmt_wren           <= #`Tcq 0;
             poll_en             <= #`Tcq 0;
             poll_dwaddr_cntr    <= #`Tcq poll_dwaddr_cntr;
             poll_dwaddr_cntr_d1 <= #`Tcq poll_dwaddr_cntr_d1;
             cfg_write_done      <= #`Tcq 1'b0;
    
          // no User request, begin a new write operation
          end else if (~cfg_wr_en_n || ~cfg_wr_en_n_hold) begin
             mgmt_addr           <= #`Tcq cfg_dwaddr;
             mgmt_rden           <= #`Tcq 0;
             mgmt_wren           <= #`Tcq 1;
             mgmt_wdata          <= #`Tcq cfg_wr_data;
             mgmt_bwren          <= #`Tcq cfg_byte_en;
             poll_en             <= #`Tcq 0;
             poll_dwaddr_cntr    <= #`Tcq poll_dwaddr_cntr;
             poll_dwaddr_cntr_d1 <= #`Tcq poll_dwaddr_cntr_d1;
             cfg_write_done      <= #`Tcq 1'b1;
          // no User request, begin a new write operation
          end else if (poll_dwrw) begin
             mgmt_addr           <= #`Tcq poll_dwaddr;
             mgmt_wdata          <= #`Tcq (poll_dwaddr_cntr == 4'b1110) ? cfg_dsn[31:0]:
                                                                          cfg_dsn[63:32];
             mgmt_rden           <= #`Tcq 0;
             mgmt_wren           <= #`Tcq 1;
             poll_en             <= #`Tcq 0;
             poll_dwaddr_cntr    <= #`Tcq poll_dwaddr_cntr + 1;
             poll_dwaddr_cntr_d1 <= #`Tcq poll_dwaddr_cntr;
             cfg_write_done      <= #`Tcq 1'b0;
          // no User request, begin a new polling operation
          end else if (~poll_dwrw) begin
             mgmt_addr           <= #`Tcq poll_dwaddr;
             mgmt_rden           <= #`Tcq 1;
             mgmt_wren           <= #`Tcq 0;
             poll_en             <= #`Tcq 1;
             poll_dwaddr_cntr    <= #`Tcq poll_dwaddr_cntr + 1;
             poll_dwaddr_cntr_d1 <= #`Tcq poll_dwaddr_cntr;
             cfg_write_done      <= #`Tcq 1'b0;
          // in the middle of a current op, hold values (except turnoff rden)
          end 
       end else begin
          mgmt_addr           <= #`Tcq mgmt_addr;
          mgmt_rden           <= #`Tcq 0;
          mgmt_wren           <= #`Tcq 0;
          poll_en             <= #`Tcq poll_en;
          poll_dwaddr_cntr    <= #`Tcq poll_dwaddr_cntr;
          poll_dwaddr_cntr_d1 <= #`Tcq poll_dwaddr_cntr_d1;
          cfg_write_done      <= #`Tcq 1'b0;
       end
    end
    
    
    
    always @(posedge clk) begin
       if (~rst_n) begin
          lock_useraccess     <= #`Tcq 0;
          wait_stg1           <= #`Tcq 0;
          wait_stg2           <= #`Tcq 0;
          poll_data_en_d      <= #`Tcq 0;
          poll_dwaddr_cntr_d2 <= #`Tcq 0;
       end else begin
          // Lock out new transactions while waiting for user access to complete
          if      (~cfg_rd_wr_done_n)
             lock_useraccess     <= #`Tcq 0;
          else if (~cfg_rd_en_n && ~mgmt_rden && ~wait_stg1 && ~lock_useraccess)
             lock_useraccess     <= #`Tcq 1;
          ////
          wait_stg1           <= #`Tcq mgmt_rden;
          wait_stg2           <= #`Tcq wait_stg1;
          poll_data_en_d      <= #`Tcq poll_data_en;
          poll_dwaddr_cntr_d2 <= #`Tcq poll_dwaddr_cntr_d1;
       end
    end
    
    assign poll_data_en = wait_stg2 && poll_en;
    assign cfg_data_en  = wait_stg2 && ~poll_en;
    assign cfg_read_done = ~cfg_rd_wr_done_n;
    
    // Indicate whether user or polled access is complete, and capture data
    always @(posedge clk) begin
       if (~rst_n) begin
          mgmt_rdata_d1     <= #`Tcq 0;
          cfg_do            <= #`Tcq 0;
          cfg_rd_wr_done_n  <= #`Tcq 1;
       end else begin
          if (poll_data_en) begin
             mgmt_rdata_d1    <= #`Tcq mgmt_rdata;
          end
          if (cfg_data_en) begin
             cfg_do           <= #`Tcq mgmt_rdata;
          end
          cfg_rd_wr_done_n  <= #`Tcq ~cfg_data_en;
       end
    end
    
    // For polled data, write captured data to shadow registers
    always @(posedge clk) begin
       if (~rst_n) begin
          cfg_status       <= #`Tcq 0;
          cfg_command      <= #`Tcq 0;
          cfg_dstatus      <= #`Tcq 0;
          cfg_dcommand     <= #`Tcq 0;
          cfg_lstatus      <= #`Tcq 0;
          cfg_lcommand     <= #`Tcq 0;
          cfg_pmcsr        <= #`Tcq 0;
          cfg_dcap         <= #`Tcq 0;
          cfg_rx_bar0      <= #`Tcq 0;
          cfg_rx_bar1      <= #`Tcq 0;
          cfg_rx_bar2      <= #`Tcq 0;
          cfg_rx_bar3      <= #`Tcq 0;
          cfg_rx_bar4      <= #`Tcq 0;
          cfg_rx_bar5      <= #`Tcq 0;
          cfg_rx_xrom      <= #`Tcq 0;
       end else if (poll_data_en_d) begin
          case (poll_dwaddr_cntr_d2)
          4'h2: begin //01
             cfg_status       <= #`Tcq mgmt_rdata_d1[31:16];    
             cfg_command      <= #`Tcq mgmt_rdata_d1[15:0];
          end
          4'h3:       //04
             cfg_rx_bar0      <= #`Tcq mgmt_rdata_d1;
          4'h4:       //05
             cfg_rx_bar1      <= #`Tcq mgmt_rdata_d1;
          4'h5:       //06
             cfg_rx_bar2      <= #`Tcq mgmt_rdata_d1;
          4'h6:       //07
             cfg_rx_bar3      <= #`Tcq mgmt_rdata_d1;
          4'h7:       //08
             cfg_rx_bar4      <= #`Tcq mgmt_rdata_d1;
          4'h8:       //09
             cfg_rx_bar5      <= #`Tcq mgmt_rdata_d1;
          4'h9:       //0c
             cfg_rx_xrom      <= #`Tcq mgmt_rdata_d1;
          4'ha: begin //2a
             cfg_dstatus      <= #`Tcq mgmt_rdata_d1[31:16];    
             cfg_dcommand     <= #`Tcq mgmt_rdata_d1[15:0];
          end
          4'hb: begin //2c
             cfg_lstatus      <= #`Tcq mgmt_rdata_d1[31:16];    
             cfg_lcommand     <= #`Tcq mgmt_rdata_d1[15:0];
          end
          4'hc:     //1e
             cfg_pmcsr        <= #`Tcq mgmt_rdata_d1;
          4'hd:     //29
             cfg_dcap         <= #`Tcq mgmt_rdata_d1;
          default: begin end
          endcase
       end
    end
    

endmodule // pcie_blk_cf_mgmt

