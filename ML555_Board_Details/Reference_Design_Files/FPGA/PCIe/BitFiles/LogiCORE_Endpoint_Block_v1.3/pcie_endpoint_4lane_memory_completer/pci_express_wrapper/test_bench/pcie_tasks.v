//------------------------------------------------------------------------------
//
// Copyright (C) 2006, Xilinx, Inc. All Rights Reserved.
//
// This file is owned and controlled by Xilinx and must be used solely
// for design, simulation, implementation and creation of design files
// limited to Xilinx devices or technologies. Use with non-Xilinx
// devices or technologies is expressly prohibited and immediately
// terminates your license.
//
// Xilinx products are not intended for use in life support
// appliances, devices, or systems. Use in such applications is
// expressly prohibited.
//
//   ____  ____
//  /   /\/   /
// /___/  \  /    Vendor      : Xilinx
// \   \   \/     Version     : 1.2
//  \   \         Application : Generated by Xilinx PCI Express Wizard
//  /   /         Filename    : pcie_tasks.v
// /___/   /\     Module      : not applicable
// \   \  /  \
//  \___\/\___\
//
//------------------------------------------------------------------------------

task find_capabilities;

  reg [7:0] temp_address;
  reg [11:0] temp_address_ext;
  reg [7:0] temp_capID;

begin
  temp_address = 52;

  while (temp_address != 0) begin

    if (temp_address == 52) begin
      $display("%d ",$time,"   Send Cfg Read Packet to find first extended capability");
      if (verbose == 1)
        $display("%d ",$time,"   3DW non-posted read with 0 data words");
        
      if (bus_number == 0) begin // type 0 config read
        tx_data_buffer[0] = {1'b1 , 32'b00000100000000000000000000000001}; // 0x04000001
        tx_data_buffer[1] = {1'b1 , 32'b01010101000000000000001100001111}; // 0x5500030F
        tx_data_buffer[2] = {1'b1 , 24'b101010100011100000000000 , temp_address};
      end
      else begin// type 1 config read
        tx_data_buffer[0] = {1'b1 , 32'b00000101000000000000000000000001}; // 0x05000001
        tx_data_buffer[1] = {1'b1 , 32'b01010101000000000000001100001111}; // 0x5500030F
        tx_data_buffer[2] = {1'b1 , bus_number , 16'b0000000000000000 , temp_address};
      end       
      user_write_dma(3'b000,2'b01,3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);
      user_read_dma(3'b000,2'b10,`WAIT_STATE_0,`READ_MODE_NORMAL,errors);
      if (bus_number == 0) begin // type 0 config read
        expected_data_buffer[0] = {1'b1 , 32'b01001010000000000000000000000001}; // 0x4A000001
        expected_data_buffer[1] = {1'b1 , completer_id , 16'b0000000000000100}; // 0xAA380004
        expected_data_buffer[2] = {1'b1 , 32'b01010101000000000000001100000000}; // 0x55000300
        expected_data_buffer[3] = {1'b0 , 32'bXXXXXXXX000000000000000000000000}; // 0x000000XX
      end
      else begin // type 1 config read
        expected_data_buffer[0] = {1'b1 , 32'b01001010000000000000000000000001}; // 0x4A000001
        expected_data_buffer[1] = {1'b1 , bus_number , 24'b000000000000000000000100}; // 0xXX000004
        expected_data_buffer[2] = {1'b1 , 32'b01010101000000000000001100000000}; // 0x55000300
        expected_data_buffer[3] = {1'b0 , 32'bXXXXXXXX000000000000000000000000}; // 0x000000XX
      end 
      check_buffer(4,errors);
      temp_address = rx_data_buffer[3][31:24];
      $display("%d ",$time,"   First extended capability found at 0x%2X",temp_address);
    end
    else begin 
      $display("%d ",$time,"   Send Cfg Read Packet to retrieve this capability");
      if (verbose == 1)
        $display("%d ",$time,"   3DW non-posted read with 0 data words");
      if (bus_number == 0) begin // type 0 config read
        tx_data_buffer[0] = {1'b1 , 32'b00000100000000000000000000000001}; // 0x04000001
        tx_data_buffer[1] = {1'b1 , 32'b01010101000000000000001100001111}; // 0x5500030F
        tx_data_buffer[2] = {1'b1 , 24'b101010100011100000000000 , temp_address};
      end
      else begin // type 1 config read
        tx_data_buffer[0] = {1'b1 , 32'b00000101000000000000000000000001}; // 0x05000001
        tx_data_buffer[1] = {1'b1 , 32'b01010101000000000000001100001111}; // 0x5500030F
        tx_data_buffer[2] = {1'b1 , bus_number , 16'b0000000000000000 , temp_address};
      end 
      user_write_dma(3'b000,2'b01,3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);
      user_read_dma(3'b000,2'b10,`WAIT_STATE_0,`READ_MODE_NORMAL,errors);
      if (bus_number == 0) begin // type 0 config read
        expected_data_buffer[0] = {1'b1 , 32'b01001010000000000000000000000001}; // 0x4A000001
        expected_data_buffer[1] = {1'b1 , completer_id , 16'b0000000000000100}; // 0xAA380004
        expected_data_buffer[2] = {1'b1 , 32'b01010101000000000000001100000000}; // 0x55000300
        expected_data_buffer[3] = {1'b0 , 32'bXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}; // 0xXXXXXXXX
      end
      else begin // type 1 config read
        expected_data_buffer[0] = {1'b1 , 32'b01001010000000000000000000000001}; // 0x4A000001
        expected_data_buffer[1] = {1'b1 , bus_number , 24'b000000000000000000000100}; // 0xXX000004
        expected_data_buffer[2] = {1'b1 , 32'b01010101000000000000001100000000}; // 0x55000300
        expected_data_buffer[3] = {1'b0 , 32'bXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}; // 0xXXXXXXXX
      end 
      check_buffer(4,errors);
      temp_capID = rx_data_buffer[3][31:24];
      if (temp_capID == `CAP_ID_PM)
        $display("%d ",$time,"   Found PM Capability");
      else if (temp_capID == `CAP_ID_AGP)
        $display("%d ",$time,"   Found AGP Capability");
      else if (temp_capID == `CAP_ID_VPD)
        $display("%d ",$time,"   Found VPD Capability");
      else if (temp_capID == `CAP_ID_SLOT)
        $display("%d ",$time,"   Found SLOT Capability");
      else if (temp_capID == `CAP_ID_MSI)
        $display("%d ",$time,"   Found MSI Capability");
      else if (temp_capID == `CAP_ID_HOTSWAP)
        $display("%d ",$time,"   Found HOTSWAP Capability");
      else if (temp_capID == `CAP_ID_PCIE)
        $display("%d ",$time,"   Found PCI-Express Capability");
      else begin
        $display("%d ",$time,"   Error: This was capability %d which is unrecognised",temp_capID);
        errors = errors + 1;
      end
      capabilities[temp_capID] = {4'b0000 , temp_address};
      #(0);

      temp_address = rx_data_buffer[3][23:16];
      if (temp_address != 0)
        $display("%d ",$time,"   Next capability found at 0x%2X",temp_address);
      else
        $display("%d ",$time,"   This was the last capability");
    end 
  end 

  temp_address_ext = 256;

  while (temp_address_ext != 0) begin

    $display("%d ",$time,"   Send Cfg Read Packet to find enhanced capability");
    if (verbose == 1)
      $display("%d ",$time,"   3DW non-posted read with 0 data words");
    if (bus_number == 0) begin // type 0 config read
      tx_data_buffer[0] = {1'b1 , 32'b00000100000000000000000000000001}; // 0x04000001
      tx_data_buffer[1] = {1'b1 , 32'b01010101000000000000001100001111}; // 0x5500030F
      tx_data_buffer[2] = {1'b1 , 20'b10101010001110000000 , temp_address_ext};
    end
    else begin// type 1 config read
      tx_data_buffer[0] = {1'b1 , 32'b00000101000000000000000000000001}; // 0x05000001
      tx_data_buffer[1] = {1'b1 , 32'b01010101000000000000001100001111}; // 0x5500030F
      tx_data_buffer[2] = {1'b1 , bus_number , 12'b000000000000 ,temp_address_ext};
    end
    user_write_dma(3'b000,2'b01,3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);
    user_read_dma(3'b000,2'b10,`WAIT_STATE_0,`READ_MODE_NORMAL,errors);
    if (bus_number == 0) begin // type 0 config read
      expected_data_buffer[0] = {1'b1 , 32'b01001010000000000000000000000001}; // 0x4A000001
      expected_data_buffer[1] = {1'b1 , completer_id , 16'b0000000000000100}; // 0xAA380004
      expected_data_buffer[2] = {1'b1 , 32'b01010101000000000000001100000000}; // 0x55000300
      expected_data_buffer[3] = {1'b0 , 32'bXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}; // 0xXXXXXXXX
    end
    else begin // type 1 config read
      expected_data_buffer[0] = {1'b1 , 32'b01001010000000000000000000000001}; // 0x4A000001
      expected_data_buffer[1] = {1'b1 , bus_number , 24'b000000000000000000000100}; // 0xXX380004
      expected_data_buffer[2] = {1'b1 , 32'b01010101000000000000001100000000}; // 0x55000300
      expected_data_buffer[3] = {1'b0 , 32'bXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}; // 0xXXXXXXXX
    end
    check_buffer(4,errors);
    temp_capID = rx_data_buffer[3][31:24];
    if (temp_capID == `CAP_ID_AER)
      $display("%d ",$time,"   Found AER Capability");
    else if (temp_capID == `CAP_ID_VC)
      $display("%d ",$time,"   Found VC Capability");
    else if (temp_capID == `CAP_ID_DSN)
      $display("%d ",$time,"   Found DSN Capability");
    else if (temp_capID == `CAP_ID_PB)
      $display("%d ",$time,"   Found PB Capability");
    else if (temp_capID == 0)
      $display("%d ",$time,"   No more enhanced capabilities found !");
    else begin
      $display("%d ",$time,"   Error: This was capability %b which is unrecognised",temp_capID);
      errors = errors + 1;
    end 
    enhanced_capabilities[temp_capID] = temp_address_ext;
    #(0);

    temp_address_ext = {4'b0000 , rx_data_buffer[3][7:0]};
    temp_address_ext = temp_address_ext * 16;
    temp_address_ext = temp_address_ext + rx_data_buffer[3][15:12];

    //temp_address_ext := conv_integer(unsigned(rx_data_buffer(3)(31 DOWNTO 20)));
    if (temp_address_ext != 0)
      $display("%d ",$time,"   Next capability found at 0x%3X",temp_address_ext);
    else 
      $display("%d ",$time,"   This was the last capability");

  end 

end
endtask


task ne_config_read;
  input [10:0]  length;
  input [7:0] st_addr;
  input [3:0]  first_be;
  input [3:0]  last_be;

  reg [11:0] byte_count;
  reg [1:0] minus_first_bytes;
  reg [1:0] minus_last_bytes;
  
begin
  @(posedge user_clk_ne);
  #1;

  if (length == 1 && last_be != 0) $display("TB Error: Last BE must be 0 for 1 DW reads");

  $display("%d ",$time," %2d DW read from ne config address 0x%2X",length, st_addr);

  case (first_be) 
    4'b1000 : minus_first_bytes = 2'b11;
    4'b1100 : minus_first_bytes = 2'b10;
    4'b1110 : minus_first_bytes = 2'b01;
    4'b1111 : minus_first_bytes = 2'b00;
    default : minus_first_bytes = 2'b00;
  endcase
  
  case (last_be) 
    4'b0001 : minus_last_bytes = 2'b11;
    4'b0011 : minus_last_bytes = 2'b10;
    4'b0111 : minus_last_bytes = 2'b01;
    4'b1111 : minus_last_bytes = 2'b00;
    default : minus_last_bytes = 2'b00;
  endcase
  
  byte_count = 4*length - minus_first_bytes - minus_last_bytes;
  
  clear_tx_buffer;
  tx_data_buffer[0] = {1'b1 , 22'b0000010000000000000000, length[9:0]};
  tx_data_buffer[1] = {1'b1 , requester_id , 8'h0, last_be, first_be}; // 0x550000XX
  tx_data_buffer[2] = {1'b1 , 24'b0, st_addr};
  
  user_write_dma(`TC_SELECT_0,`FIFO_SELECT_CONFIG,3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);

  

  // load expected buffer before address changes
  //clear_expected_buffer;
  //expected_data_buffer[0] = {1'b1 , 22'b0100101000000000000000, length[9:0]};
  //expected_data_buffer[1] = {1'b1 , 20'bXXXXXXXXXXXXXXXX000X, byte_count}; // 0xXXXX0004
  //expected_data_buffer[2] = {1'b1 , requester_id , 9'b000000000 , st_addr[6:0]};
  //
  //for (j=0; j < length; j=j+1) //begin
  //   expected_data_buffer[3+j] = {1'b0 , expected_data[j][31:0]};

  // grab completion
  user_read_dma(`TC_SELECT_0,`FIFO_SELECT_CONFIG,`WAIT_STATE_0,`READ_MODE_NORMAL,errors);
  $display("   Read %9X from rx_data_buffer[0]", rx_data_buffer[0][31:0]);
  $display("   Read %9X from rx_data_buffer[1]", rx_data_buffer[1][31:0]);
  $display("   Read %9X from rx_data_buffer[2]", rx_data_buffer[2][31:0]);
  $display("   Read %9X from rx_data_buffer[3]", rx_data_buffer[3][31:0]);
  //$display("Checking %2d DW read from address 0x%2X", length, st_addr);
  //check_buffer(4+length-1,errors);
end
endtask


task ne_config_write;
  input [10:0]  length;
  input [7:0] st_addr;
  input [3:0]  first_be;
  input [3:0]  last_be;

  integer j;
begin
  @(posedge user_clk_ne);
  #1;

  if (length == 1 && last_be != 0) $display("TB Error: Last BE must be 0 for 1 DW writes");

  $display("%d ",$time," %2d DW write to ne config address 0x%2X",length, st_addr);
        
  clear_tx_buffer;
  // Create header
  tx_data_buffer[0] = {1'b1 , 22'b0100010000000000000000, length[9:0]};
  tx_data_buffer[1] = {1'b1 , requester_id , 8'h0, last_be, first_be}; // 0x550000XX
  tx_data_buffer[2] = {1'b1 , 24'b0, st_addr};

  // Create data portion  
  for (j=0; j < length; j=j+1) begin
    tx_data_buffer[j+3] = {1'b0, tx_data_to_send[j]};
  end

  //$display("Calling user_write_dma with the following arguments, 0x%1X, 0x%1X, %2d, %2d, %2d", 
  //  `TC_SELECT_0,`FIFO_SELECT_POSTED,length+3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);
    
  // Start transmission  
  user_write_dma(`TC_SELECT_0,`FIFO_SELECT_CONFIG,length+3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);
  
  // Grab completion and ignore
  //$display("   Wait for completion...");
  user_read_dma(`TC_SELECT_0,`FIFO_SELECT_CONFIG,`WAIT_STATE_0,`READ_MODE_NORMAL,errors);
  
  //user_read_dma(`TC_SELECT_0,`FIFO_SELECT_COMPLETION,`WAIT_STATE_0,`READ_MODE_NORMAL,errors);
  //$display("   Read data %9X from rx_data_buffer[0]", rx_data_buffer[0][31:0]);
  //$display("   Read data %9X from rx_data_buffer[1]", rx_data_buffer[1][31:0]);
  //$display("   Read data %9X from rx_data_buffer[2]", rx_data_buffer[2][31:0]);
  //$display("   Read data %9X from rx_data_buffer[3]", rx_data_buffer[3][31:0]);
  

end
endtask

task config0_write;
  input [10:0]  length;
  input [31:0] st_addr;
  input [3:0]  first_be;
  input [3:0]  last_be;

  integer j;
begin
  @(posedge user_clk_ne);
  #1;

  if (length == 1 && last_be != 0) $display("TB Error: Last BE must be 0 for 1 DW writes");

  $display("%d ",$time," %2d DW write to config address 0x%2X",length, st_addr);
        
  clear_tx_buffer;
  // Create header
  tx_data_buffer[0] = {1'b1 , 22'b0100010000000000000000, length[9:0]};
  tx_data_buffer[1] = {1'b1 , requester_id , 8'h0, last_be, first_be}; // 0x550000XX
  tx_data_buffer[2] = {1'b1 , st_addr};

  // Create data portion  
  for (j=0; j < length; j=j+1) begin
    tx_data_buffer[j+3] = {1'b0, tx_data_to_send[j]};
  end

  //$display("Calling user_write_dma with the following arguments, 0x%1X, 0x%1X, %2d, %2d, %2d", 
  //  `TC_SELECT_0,`FIFO_SELECT_POSTED,length+3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);
    
  // Start transmission  
  user_write_dma(`TC_SELECT_0,`FIFO_SELECT_NON_POSTED,length+3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);
  
  // Grab completion and ignore
  user_read_dma(`TC_SELECT_0,`FIFO_SELECT_COMPLETION,`WAIT_STATE_0,`READ_MODE_NORMAL,errors);
  //$display("   Read completion %9X from rx_data_buffer[0]", rx_data_buffer[0][31:0]);
  //$display("   Read completion %9X from rx_data_buffer[1]", rx_data_buffer[1][31:0]);
  //$display("   Read completion %9X from rx_data_buffer[2]", rx_data_buffer[2][31:0]);
  

end
endtask

task config0_read;
  input [10:0]  length;
  input [31:0] st_addr;
  input [3:0]  first_be;
  input [3:0]  last_be;

  reg [11:0] byte_count;
  reg [1:0] minus_first_bytes;
  reg [1:0] minus_last_bytes;
  
begin
  @(posedge user_clk_ne);
  #1;

  if (length == 1 && last_be != 0) $display("TB Error: Last BE must be 0 for 1 DW reads");

  $display("%d ",$time," %2d DW read from config address 0x%2X",length, st_addr);

  case (first_be) 
    4'b1000 : minus_first_bytes = 2'b11;
    4'b1100 : minus_first_bytes = 2'b10;
    4'b1110 : minus_first_bytes = 2'b01;
    4'b1111 : minus_first_bytes = 2'b00;
    default : minus_first_bytes = 2'b00;
  endcase
  
  case (last_be) 
    4'b0001 : minus_last_bytes = 2'b11;
    4'b0011 : minus_last_bytes = 2'b10;
    4'b0111 : minus_last_bytes = 2'b01;
    4'b1111 : minus_last_bytes = 2'b00;
    default : minus_last_bytes = 2'b00;
  endcase
  
  byte_count = 4*length - minus_first_bytes - minus_last_bytes;
  
  clear_tx_buffer;
  tx_data_buffer[0] = {1'b1 , 22'b0000010000000000000000, length[9:0]};
  tx_data_buffer[1] = {1'b1 , requester_id , 8'h0, last_be, first_be}; // 0x550000XX
  tx_data_buffer[2] = {1'b1 , st_addr};
  
  user_write_dma(`TC_SELECT_0,`FIFO_SELECT_NON_POSTED,3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);
  
  user_read_dma(`TC_SELECT_0,`FIFO_SELECT_COMPLETION,`WAIT_STATE_0,`READ_MODE_NORMAL,errors);
  $display("   Read %9X from rx_data_buffer[0]", rx_data_buffer[0][31:0]);
  $display("   Read %9X from rx_data_buffer[1]", rx_data_buffer[1][31:0]);
  $display("   Read %9X from rx_data_buffer[2]", rx_data_buffer[2][31:0]);
  $display("   Read %9X from rx_data_buffer[3]", rx_data_buffer[3][31:0]);
end
endtask

task memory_read;
  input [10:0]  length;
  input [31:0] st_addr;
  input [2:0]  tc;
  input [3:0]  first_be;
  input [3:0]  last_be;

  reg [11:0] byte_count;
  reg [1:0] minus_first_bytes;
  reg [1:0] minus_last_bytes;
  
begin
  @(posedge user_clk_ne);
  #1;

  if (length == 1 && last_be != 0) $display("TB Error: Last BE must be 0 for 1 DW reads");

  $display("%d ",$time," %2d DW read from address 0x%2X",length, st_addr);

  case (first_be) 
    4'b1000 : minus_first_bytes = 2'b11;
    4'b1100 : minus_first_bytes = 2'b10;
    4'b1110 : minus_first_bytes = 2'b01;
    4'b1111 : minus_first_bytes = 2'b00;
    default : minus_first_bytes = 2'b00;
  endcase
  
  case (last_be) 
    4'b0001 : minus_last_bytes = 2'b11;
    4'b0011 : minus_last_bytes = 2'b10;
    4'b0111 : minus_last_bytes = 2'b01;
    4'b1111 : minus_last_bytes = 2'b00;
    default : minus_last_bytes = 2'b00;
  endcase
  
  byte_count = 4*length - minus_first_bytes - minus_last_bytes;
  
  clear_tx_buffer;
  //tx_data_buffer[0] = {1'b1 , 22'h0, length[9:0]};
  tx_data_buffer[0] = {1'b1,  1'b0, 2'b00, 5'b0, 1'b0, tc, 4'b0, 1'b0, 1'b0, 2'b0, 2'b0, length[9:0]};
  tx_data_buffer[1] = {1'b1 , requester_id , 8'h0, last_be, first_be}; // 0x550000XX
  tx_data_buffer[2] = {1'b1 , st_addr};
  
  //$display("tx_data_buffer[0] = 0x%9X", tx_data_buffer[0]);
  //$display("tx_data_buffer[1] = 0x%9X", tx_data_buffer[1]);
  //$display("tx_data_buffer[2] = 0x%9X", tx_data_buffer[2]);
  
  user_write_dma(tc,`FIFO_SELECT_NON_POSTED,3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);

  // load expected buffer before address changes
  clear_expected_buffer;
  expected_data_buffer[0] = {1'b1,  1'b0, 2'b10, 5'b01010, 1'b0, tc, 4'b0, 1'b0, 1'b0, 2'b0, 2'b0, length[9:0]};
  expected_data_buffer[1] = {1'b1 , 20'bXXXXXXXXXXXXXXXX000X, byte_count}; // 0xXXXX0004
  expected_data_buffer[2] = {1'b1 , requester_id , 9'b000000000 , st_addr[6:0]};
  
  for (j=0; j < length; j=j+1) //begin
     expected_data_buffer[3+j] = {1'b0 , expected_data[j][31:0]};

  
  user_read_dma(tc,`FIFO_SELECT_COMPLETION,`WAIT_STATE_0,`READ_MODE_NORMAL,errors);
  $display("Checking %2d DW read from address 0x%2X", length, st_addr);
  check_buffer(4+length-1,errors);
end
endtask


task memory_write;
  input [10:0] length; //payload length
  input [31:0] st_addr;
  input [2:0]  tc;
  input [3:0]  first_be;
  input [3:0]  last_be;

  integer j;
begin
  @(posedge user_clk_ne);
  #1;

  if (length == 1 && last_be != 0) $display("TB Error: Last BE must be 0 for 1 DW writes");

  $display("%d ",$time," %2d DW write to address 0x%2X",length, st_addr);
        
  clear_tx_buffer;
  // Create header
  tx_data_buffer[0] = {1'b1,  1'b0, 2'b10, 5'b0, 1'b0, tc, 4'b0, 1'b0, 1'b0, 2'b0, 2'b0, length[9:0]};
  tx_data_buffer[1] = {1'b1 , requester_id , 8'h0, last_be, first_be}; // 0x550000XX
  tx_data_buffer[2] = {1'b1 , st_addr};

  // Create data portion  
  for (j=0; j < length; j=j+1) begin
    tx_data_buffer[j+3] = {1'b0, tx_data_to_send[j]};
  end

  //$display("Calling user_write_dma with the following arguments, 0x%1X, 0x%1X, %2d, %2d, %2d", 
  //  `TC_SELECT_0,`FIFO_SELECT_POSTED,length+3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);
    
  // Start transmission  
  user_write_dma(tc,`FIFO_SELECT_POSTED,length+3,`WAIT_STATE_0,`WRITE_MODE_NORMAL);

end
endtask

//---------------------------------------------------------------------
// USER SIDE FUNCTIONS
//---------------------------------------------------------------------
task user_write_dma;
  input [2:0] tc; // traffic class
  input [1:0] wtype; //write type: 00:posted, 01:non posted, 10:completion
  input integer count; // payload length + 3 DW header
  input integer wait_states; //0
  input integer write_mode;  //0

  integer TB_USER_TIMEOUT_INT;
  integer found;
  reg [1:0] packet_format;
  reg [63:0] write_data;
  reg [1:0] write_enable;
  reg ready_selected;
  integer I;
  integer data_xfer;
  integer break_count;
  integer loop_counter;
begin

//  $display("In user_write_dma with the following inputs, %b:",tc,"%b:",wtype,"%d:",count,
//   "%d:"wait_states, "%d:"write_mode); 

  TB_USER_TIMEOUT_INT = (`TB_USER_TIMEOUT * USER_CLK_PERIOD);
    
  // Bit 32 = 1 of the tx_data_buffer[I] indicates the DW is a part of the header
  // packet format [1:0] indicates a write or a read 
  // For Config Requets  00 = READ(3DW w/o data) 10 = WRITE (3DW with data)  
  // For Memory Requests 00 = READ(3DW w/o data) 10 = WRITE (3DW with data)
  found = 0;
  for (I=0; (I < count && found == 0); I=I+1) begin
    if (tx_data_buffer[I][32] == 1'b1) begin
      packet_format = tx_data_buffer[I][30:29];   
      found = 1;     
    end
  end

  if (found == 0 && (write_mode & (1<<`WRITE_MODE_DISCARD_BIT)) == 0) begin
    $display("%d ",$time,"  TB Error: No header in the transmitted packet");
  end

  if (wtype == 2'b00 && ((write_mode & (1<<`WRITE_MODE_DISCARD_BIT)) == 0))
    ne_transmitted_packets_p = ne_transmitted_packets_p + 1;
  else if (wtype == 2'b01 && ((write_mode & (1<<`WRITE_MODE_DISCARD_BIT)) == 0))
    ne_transmitted_packets_np = ne_transmitted_packets_np + 1;
  else if (wtype == 2'b10 && ((write_mode & (1<<`WRITE_MODE_DISCARD_BIT)) == 0))
    ne_transmitted_packets_c = ne_transmitted_packets_c + 1;


  //tx_tc_select = tc;
  //tx_fifo_select = wtype;
  //tx_4dw_header = packet_format[0]; tiedoff
  //tx_first = 1'b1;
  //tx_complete = 1'b0;tiedoff
  
  @(posedge user_clk_ne);


  //if ((write_mode & (1<<`WRITE_MODE_ECRC_BIT)) != 0) begin
  //  tx_create_ecrc = 1'b1;
  //end
  //else begin
  //  tx_create_ecrc = 1'b0;
  //end

  I = 0;
  while (I <= (count-1)) begin
    llk_tx_ch_tc = tc;
    llk_tx_ch_fifo = wtype;  
    write_data[63:0] = { tx_data_buffer[I][31:0] , tx_data_buffer[I+1][31:0] };
        if (I == 0)
            llk_tx_sof_n =  ~(tx_data_buffer[I][32]);
        else llk_tx_sof_n =  1'b1;
        
        if (I == 2)
            llk_tx_sop_n =  ~(tx_data_buffer[I][32]);
        else llk_tx_sop_n =  1'b1;

        if ((I == count-1) || (tx_data_buffer[I][32] == 1'b0 && tx_data_buffer[I+1][32] == 1'b1)) begin
            write_enable = 2'b10;
            data_xfer = 1; //only 1 DW in the last 64 bits 
        end
        else begin
            write_enable = 2'b11;
            data_xfer = 2;
        end
    llk_tx_data = write_data[63:0];

    if ((I + (data_xfer - 1)) >= count-1) begin
        llk_tx_eop_n = 1'b0;
        llk_tx_eof_n = 1'b0;
    end
    else begin
        llk_tx_eop_n = 1'b1;
        llk_tx_eof_n = 1'b1; 
    end    
    

    if (wtype == 2'b00)
      ready_selected = ~(llk_tx_ch_posted_ready_n[tc]);
    else if (wtype == 2'b01)
      ready_selected = ~(llk_tx_ch_non_posted_ready_n[tc]);
    else if (wtype == 2'b10)
      ready_selected = ~(llk_tx_ch_completion_ready_n[tc]);
    else
      ready_selected = ~(llk_tx_ch_config_ready_n);
    
    loop_counter = 0;
    break_count = 0;
    while (ready_selected == 0 && loop_counter < TB_USER_TIMEOUT_INT && break_count == 0) begin
      #(USER_CLK_PERIOD);
      
      if (wtype == 2'b00)
        ready_selected = ~(llk_tx_ch_posted_ready_n[tc]);
      else if (wtype == 2'b01)
        ready_selected = ~(llk_tx_ch_non_posted_ready_n[tc]);
      else if (wtype == 2'b10)
        ready_selected = ~(llk_tx_ch_completion_ready_n[tc]);
      else
        ready_selected = ~(llk_tx_ch_config_ready_n);
      
      if (ready_selected == 1)
        break_count = 1;
      
      loop_counter = loop_counter + 1;
    end

    if (loop_counter >= TB_USER_TIMEOUT_INT) begin
      $display("%d ",$time,"  **Error: Write Timeout");
      $finish;
    end

    llk_tx_enable_n = ~ (write_enable);
    llk_tx_src_rdy_n = ~(|write_enable);


    #(USER_CLK_PERIOD * wait_states);
    #(USER_CLK_PERIOD);

    I = I + data_xfer;
  end

    llk_tx_ch_tc             =   3'b0;  
    llk_tx_ch_fifo           =   2'b0;  
    llk_tx_enable_n          =   2'b11; 
    llk_tx_data              =   63'b0; 
    llk_tx_src_rdy_n         =   1'b1;  
    llk_tx_sof_n             =   1'b1;  
    llk_tx_eof_n             =   1'b1;  
    llk_tx_sop_n             =   1'b1;  
    llk_tx_eop_n             =   1'b1;  

end
endtask

task user_read_dma;
  input [2:0] tc; //traffic class
  input [1:0] rtype; //read type: 00:posted, 01:non posted, 10:completion
  input integer wait_states;//0
  input integer read_mode;//0
  inout integer errors;

  integer TB_USER_TIMEOUT_INT;
  integer TB_LINK_NEG_TIMEOUT_INT;
  reg read_success;
  reg selected_flag;
  reg [31:0] read_data;
  integer header_dw;
  reg is_header_dw;
  integer I;
  integer buffer_index;
  integer break_count;
  integer wait_count;
begin //1

  TB_USER_TIMEOUT_INT = (`TB_USER_TIMEOUT * USER_CLK_PERIOD) / 8;
  TB_LINK_NEG_TIMEOUT_INT = `TB_LINK_NEG_TIMEOUT / USER_CLK_PERIOD;

  @(posedge user_clk_ne);

    //check that there is data to read
      if (rtype == 2'b00)
        selected_flag = ~(llk_rx_ch_posted_available_n[tc]);
      else if (rtype == 2'b01)
        selected_flag = ~(llk_rx_ch_non_posted_available_n[tc]);
      else if (rtype == 2'b10)
        selected_flag = ~(llk_rx_ch_completion_available_n[tc]);
      else
        selected_flag = ~(llk_rx_ch_config_available_n);        

    // if there is no data to read wait for data to become available
    // break_count to keep track of when data is avaibale
    // tc should be intialised and data should be available for a read to happen
    if (selected_flag == 0) begin //2
      break_count = 0;
      while (selected_flag == 0 || llk_tc_status[tc] == 0 && break_count < TB_USER_TIMEOUT_INT) begin //3
        #(USER_CLK_PERIOD);
        if (rtype == 2'b00)
          selected_flag = ~(llk_rx_ch_posted_available_n[tc]);
        else if (rtype == 2'b01)
          selected_flag = ~(llk_rx_ch_non_posted_available_n[tc]);
        else if (rtype == 2'b10)
          selected_flag = ~(llk_rx_ch_completion_available_n[tc]);
        else
          selected_flag = ~(llk_rx_ch_config_available_n);

        break_count = break_count + 1;

      end //3

      if ((break_count >= TB_USER_TIMEOUT_INT)) begin//4
        $display("%d ",$time,"  **Error: Read Timeout");
        $finish;
      end//4
    end//2
   
   // At this point selected_flag = 1 , llk_tc_status[tc] = 1
   // Hence issuing read request 
    llk_rx_dst_req_n = 1'b0;

    //read the data
    buffer_index = 0;
    llk_rx_ch_tc = tc;
    llk_rx_ch_fifo = rtype;
    wait_count = 0;
    // As of now supports 3 DW headers only, and data packets with header before data
    header_dw = 3;
    
    while (llk_rx_eof_n !=0  && wait_count < TB_USER_TIMEOUT_INT) begin //5
    
        // dst_req needs to be deasserted asynchronously
        if (llk_rx_src_last_req_n == 0) 
            llk_rx_dst_req_n = 1'b1;

        if (wait_count % USER_CLK_PERIOD == 0) begin      
            if (llk_rx_src_rdy_n == 0) begin
              for (I=1; I >= 0; I=I-1) begin
                if (llk_rx_valid_n[I] == 1'b0) begin
                  read_data = (llk_rx_data >> (I*32) ) & 32'hFFFF_FFFF;
                  if (buffer_index <= header_dw -1)
                    is_header_dw = 1;
                  else
                    is_header_dw = 0;
                  rx_data_buffer[buffer_index] = {is_header_dw, read_data };
                  buffer_index = buffer_index + 1;
                end
              end
            end
        end
        #(1)
        wait_count = wait_count + 1;
    end//5
    
    if (llk_rx_eof_n == 0) begin
        for (I=1; I >= 0; I=I-1) begin
            if (llk_rx_valid_n[I] == 1'b0) begin
              read_data = (llk_rx_data >> (I*32) ) & 32'hFFFF_FFFF;
              if (buffer_index <= header_dw -1)
                is_header_dw = 1;
              else
                is_header_dw = 0;
              rx_data_buffer[buffer_index] = {is_header_dw, read_data };
              buffer_index = buffer_index + 1;
            end
        end
    end    
        

    llk_rx_dst_req_n = 1;
    llk_rx_ch_tc = 0;
    llk_rx_ch_fifo = 0;

  if (wait_count >= TB_USER_TIMEOUT_INT) begin
    $display("%d ",$time,"  **Error: Read Timeout");
    errors = errors + 1;
  end
  else if (verbose == 1) begin
    $display("%d ",$time,"   Read Packet of %d words",buffer_index);
  end

end //1
endtask

//---------------------------------------------------------------------
// Testbench system functions
//---------------------------------------------------------------------

task initialise;
begin

  llk_tx_data              =   63'b0; 
  llk_tx_src_rdy_n         =   1'b1;  
  llk_tx_sof_n             =   1'b1;  
  llk_tx_eof_n             =   1'b1;  
  llk_tx_sop_n             =   1'b1;  
  llk_tx_eop_n             =   1'b1;  
  llk_tx_enable_n          =   2'b11; 
  llk_tx_ch_tc             =   3'b0;  
  llk_tx_ch_fifo           =   2'b0;  

  llk_rx_dst_req_n         =   1'b1;  
  llk_rx_ch_tc             =   3'b0;  
  llk_rx_ch_fifo           =   2'b0;  

end
endtask

task clear_tx_buffer;
  integer I;
begin
  for (I=0; I<`BUFFER_DEPTH; I=I+1) tx_data_buffer[I] = 0;
end
endtask

task clear_rx_buffer;
  integer I;
begin
  for (I=0; I<`BUFFER_DEPTH; I=I+1) rx_data_buffer[I] = 0;
end
endtask

task clear_expected_buffer;
  integer I;
begin
  for (I=0; I<`BUFFER_DEPTH; I=I+1) expected_data_buffer[I] = 0;
end
endtask

task copy_tx_buffer;
  integer I;
begin
  for (I=0; I<`BUFFER_DEPTH; I=I+1) expected_data_buffer[I] = tx_data_buffer[I];
end
endtask

task check_buffer;
  input integer count;
  inout integer errors;

  integer failed;
  integer break_count;
  integer I, J, K;
  integer read_pointer;
begin
  failed = 0;
  read_pointer = 0;

  for (I=0; (I < count && failed == 0); I=I+1) begin
    for (J=0; (J < 33 && failed == 0); J=J+1) begin
      if (rx_data_buffer[I][J] != 1'b1 && rx_data_buffer[I][J] != 1'b0) begin
        $display("%d ",$time,"  Error: 'U'|'X'|'W'|'Z'|'-' in the received packet");
        failed = 1;
      end
    end
  end

  if (failed == 0) begin
    for (I=0; (I < count && failed == 0); I=I+1) begin
      if (read_pointer >= count) begin
        $display("%d ",$time,"  Error: Next data word (%3d) is outside checking range (%3d)",read_pointer,count);
        failed = 1;
      end
      else begin
        for (K=0; (K < 32 && failed == 0); K=K+1) begin
          if (expected_data_buffer[I][K] == 1'b0 || expected_data_buffer[I][K] == 1'b1) begin
            if (expected_data_buffer[I][K] != rx_data_buffer[read_pointer][K]) failed = 1;
          end
        end
        if (failed == 1)
          $display("%d ",$time,"  Error: Packet Error in data (%3d) and (%3d) : 0x%32b /= 0x%32b",I,read_pointer,expected_data_buffer[I][31:0],rx_data_buffer[read_pointer][31:0]);
        else
          read_pointer = read_pointer + 1;
      end
    end
  end

  if (failed == 0)
    $display("%d ",$time,"   Received packet checked okay");
  else
    errors = errors + 1;

end
endtask
