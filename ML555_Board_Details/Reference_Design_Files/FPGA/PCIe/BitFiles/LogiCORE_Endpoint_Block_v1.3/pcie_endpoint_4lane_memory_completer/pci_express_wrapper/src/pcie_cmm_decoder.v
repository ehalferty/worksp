//------------------------------------------------------------------------------
//
// Copyright (C) 2006, Xilinx, Inc. All Rights Reserved.
//
// This file is owned and controlled by Xilinx and must be used solely
// for design, simulation, implementation and creation of design files
// limited to Xilinx devices or technologies. Use with non-Xilinx
// devices or technologies is expressly prohibited and immediately
// terminates your license.
//
// Xilinx products are not intended for use in life support
// appliances, devices, or systems. Use in such applications is
// expressly prohibited.
//
//   ____  ____
//  /   /\/   /
// /___/  \  /    Vendor      : Xilinx
// \   \   \/     Version     : 1.3
//  \   \         Application : Generated by Xilinx PCI Express Wizard
//  /   /         Filename    : pcie_cmm_decoder.v
// /___/   /\     Module      : pcie_cmm_decoder
// \   \  /  \
//  \___\/\___\
//
//
//--------------------------------------------------------------------------------

`timescale 1 ns / 1 ps

module pcie_cmm_decoder (

        input  wire      [63:0]      raddr,
        input  wire                  rmem32,
        input  wire                  rmem64,
        input  wire                  rio,
        input  wire                  rcheck_bus_id,
        input  wire                  rcheck_dev_id,
        input  wire                  rcheck_fun_id,
        output reg                   rhit,
        output wire       [6:0]      bar_hit_dd,
        output reg                   cmmt_rbar_hit_lat2_n,
        input  wire      [15:0]      command,
        input  wire      [31:0]      bar0_reg,
        input  wire      [31:0]      bar1_reg,
        input  wire      [31:0]      bar2_reg,
        input  wire      [31:0]      bar3_reg,
        input  wire      [31:0]      bar4_reg,
        input  wire      [31:0]      bar5_reg,
        input  wire      [31:0]      xrom_reg,
        input  wire      [15:0]      pme_pmcsr,
        input  wire       [7:0]      bus_num,
        input  wire       [4:0]      device_num,
        input  wire       [2:0]      function_num,
        input  wire     [671:0]      cfg,
        input  wire                  llk_rx_eof_n_d4,
        input  wire                  rst,
        input  wire                  clk
     );


    parameter Tcq = 1;
    
    wire     allow_mem;
    wire     allow_io;
    wire     bar01_64;
    wire     bar23_64;
    wire     bar45_64;
    
    //command_register[0] indicates IO space enable
    //command_register[1] indicates mem space enable
    // Signals are set only if the power state is D0 = 00
    assign allow_mem = command[1] & !pme_pmcsr[1] & !pme_pmcsr[0]; 
    assign allow_io = command[0] & !pme_pmcsr[1] & !pme_pmcsr[0]; 
    
    // 64 bit programmability built into bar registers
    // bit 3 of the bar register indicates a 64 bit decoder or a 32 bit decoder 
    assign bar01_64 = (bar0_reg[2:0] == 3'b100); 
    assign bar23_64 = (bar2_reg[2:0] == 3'b100); 
    assign bar45_64 = (bar4_reg[2:0] == 3'b100); 
    
    // 32 bits bar hits
    
    wire      bar0_32_hit; 
    wire      bar1_32_hit; 
    wire      bar2_32_hit; 
    wire      bar3_32_hit; 
    wire      bar4_32_hit; 
    wire      bar5_32_hit; 
    wire      bar6_32_hit; 
    reg       bar0_32_hit_nc; 
    reg       bar1_32_hit_nc; 
    reg       bar2_32_hit_nc; 
    reg       bar3_32_hit_nc; 
    reg       bar4_32_hit_nc; 
    reg       bar5_32_hit_nc; 
    reg       bar6_32_hit_nc; 
    reg       bar0_eq_raddr;
    reg       bar1_eq_raddr;
    reg       bar2_eq_raddr;
    reg       bar3_eq_raddr;
    reg       bar4_eq_raddr;
    reg       bar5_eq_raddr;
    reg       bar6_eq_raddr;
    
    reg [6:0] bar_hit;
    reg [6:0] bar_hit_d;
    
    
    always @(posedge clk or posedge rst) begin
       if (rst) begin
          bar0_eq_raddr  <= #Tcq 0;
          bar1_eq_raddr  <= #Tcq 0;
          bar2_eq_raddr  <= #Tcq 0;
          bar3_eq_raddr  <= #Tcq 0;
          bar4_eq_raddr  <= #Tcq 0;
          bar5_eq_raddr  <= #Tcq 0;
          bar6_eq_raddr  <= #Tcq 0;
          bar0_32_hit_nc <= #Tcq  0;  
          bar1_32_hit_nc <= #Tcq  0;  
          bar2_32_hit_nc <= #Tcq  0;  
          bar3_32_hit_nc <= #Tcq  0;  
          bar4_32_hit_nc <= #Tcq  0;  
          bar5_32_hit_nc <= #Tcq  0;  
          bar6_32_hit_nc <= #Tcq  0;  
       end
       else begin
          
          //anding the read address with the base address register
          //if it returns the base address then it belongs to that bar
          bar0_eq_raddr <= #Tcq ((raddr[63:36] & cfg[95:68])   == bar0_reg[31:4]);
          bar1_eq_raddr <= #Tcq ((raddr[63:36] & cfg[127:100]) == bar1_reg[31:4]);
          bar2_eq_raddr <= #Tcq ((raddr[63:36] & cfg[159:132]) == bar2_reg[31:4]);
          bar3_eq_raddr <= #Tcq ((raddr[63:36] & cfg[191:164]) == bar3_reg[31:4]);
          bar4_eq_raddr <= #Tcq ((raddr[63:36] & cfg[223:196]) == bar4_reg[31:4]);
          bar5_eq_raddr <= #Tcq ((raddr[63:36] & cfg[255:228]) == bar5_reg[31:4]);
          bar6_eq_raddr <= #Tcq ((raddr[63:43] & cfg[351:331]) == xrom_reg[31:11]);
                                     //32 bit mem & mem enabled & not io | io & io enabled & io   & 
                                     //why shud cfg be non zero
          bar0_32_hit_nc <= #Tcq  ((rmem32 & allow_mem & !cfg[64]) | (rio & allow_io & cfg[64])) & (|cfg[95:64]) &  
                                (!bar01_64 | (bar01_64 && (bar1_reg == 0))); 
    
          bar1_32_hit_nc <= #Tcq  ((rmem32 & allow_mem & !cfg[96]) | (rio & allow_io & cfg[96])) & (|cfg[127:96]) & !bar01_64;
    
          bar2_32_hit_nc <= #Tcq  ((rmem32 & allow_mem & !cfg[128]) | (rio & allow_io & cfg[128])) & (|cfg[159:128]) & 
                                (!bar23_64 | (bar23_64 && (bar3_reg == 0)));
    
          bar3_32_hit_nc <= #Tcq  ((rmem32 & allow_mem & !cfg[160]) | (rio & allow_io & cfg[160])) & (|cfg[191:160]) &  !bar23_64;
    
          bar4_32_hit_nc <= #Tcq  ((rmem32 & allow_mem & !cfg[192]) | (rio & allow_io & cfg[192])) & (|cfg[224:192]) &
                                (!bar45_64 | (bar45_64 && (bar5_reg == 0)));
    
          bar5_32_hit_nc <= #Tcq  ((rmem32 & allow_mem & !cfg[224]) | (rio & allow_io & cfg[224])) & (|cfg[255:224]) &  !bar45_64;
    
          bar6_32_hit_nc <= #Tcq   (rmem32 & xrom_reg[0] & allow_mem) & |cfg[351:327];
       end
    end
    
    assign  bar0_32_hit = bar0_32_hit_nc & bar0_eq_raddr;
    assign  bar1_32_hit = bar1_32_hit_nc & bar1_eq_raddr;
    assign  bar2_32_hit = bar2_32_hit_nc & bar2_eq_raddr;
    assign  bar3_32_hit = bar3_32_hit_nc & bar3_eq_raddr;
    assign  bar4_32_hit = bar4_32_hit_nc & bar4_eq_raddr;
    assign  bar5_32_hit = bar5_32_hit_nc & bar5_eq_raddr;
    assign  bar6_32_hit = bar6_32_hit_nc & bar6_eq_raddr;
    
    
    // 64 bit bar hits
    
    reg      bar01_64_hit_low; 
    reg      bar23_64_hit_low; 
    reg      bar45_64_hit_low; 
    
    reg      bar01_64_hit_high; 
    reg      bar23_64_hit_high; 
    reg      bar45_64_hit_high; 
    
    
    wire     bar01_64_hit; 
    wire     bar23_64_hit; 
    wire     bar45_64_hit; 
    
    assign  bar01_64_hit = bar01_64_hit_low &&  bar01_64_hit_high; 
    assign  bar23_64_hit = bar23_64_hit_low &&  bar23_64_hit_high; 
    assign  bar45_64_hit = bar45_64_hit_low &&  bar45_64_hit_high; 
    
    always @(posedge clk or posedge rst) begin
       if (rst) begin
          bar01_64_hit_low  <= #Tcq  0; 
          bar01_64_hit_high <= #Tcq  0; 
          bar23_64_hit_low  <= #Tcq  0; 
          bar23_64_hit_high <= #Tcq  0; 
          bar45_64_hit_low  <= #Tcq  0; 
          bar45_64_hit_high <= #Tcq  0; 
       end
       else begin
          bar01_64_hit_low  <= #Tcq  (rmem64 & allow_mem) & ((raddr[63:32] & cfg[127:96]) == bar1_reg[31:0]) & |cfg[127:96]; 
          bar01_64_hit_high <= #Tcq  ((raddr[31:4] & cfg[95:68]) == bar0_reg[31:4]) &  bar01_64 & |cfg[95:64]; 
    
          bar23_64_hit_low  <= #Tcq  (rmem64 & allow_mem) & ((raddr[63:32] & cfg[191:160]) == bar3_reg[31:0]) & |cfg[191:160];
          bar23_64_hit_high <= #Tcq  ((raddr[31:4] & cfg[159:132]) == bar2_reg[31:4]) &  bar23_64 & |cfg[159:128]; 
    
          bar45_64_hit_low  <= #Tcq  (rmem64 & allow_mem) & ((raddr[63:32] & cfg[255:224]) == bar5_reg[31:0]) & |cfg[255:224];
          bar45_64_hit_high <= #Tcq  ((raddr[31:4] & cfg[223:196]) == bar4_reg[31:4]) &  bar45_64 & |cfg[223:192]; 
       end
    end
    
    // bdf hit
    
    reg bdf_hit;
    reg bdf_check;
    
    always @(posedge clk or posedge rst)
    begin
       if (rst) begin 
           bdf_hit   <= #Tcq  0; 
           bdf_check <= #Tcq  0; 
       end
       else begin
           bdf_hit   <= #Tcq  ({bus_num,device_num,function_num} == raddr[63:48]); 
           bdf_check <= #Tcq  rcheck_bus_id | rcheck_dev_id | rcheck_fun_id; 
       end
    end
    
    
    always@(posedge clk or posedge rst) 
    begin
       if (rst) begin
          rhit <= #Tcq  0;
       end
       else begin
                     
          rhit <= #Tcq  (bdf_hit && bdf_check) | bar01_64_hit|             
                     bar23_64_hit | bar45_64_hit |            
                     bar0_32_hit | bar1_32_hit | bar2_32_hit | bar3_32_hit |             
                     bar4_32_hit | bar5_32_hit | bar6_32_hit;            
                     
       end
          
    end
    
    always@(posedge clk or posedge rst) 
    begin
       if (rst) begin
          bar_hit[6:0]         <= #Tcq 6'b000000;
          cmmt_rbar_hit_lat2_n <= #Tcq 0;
       end
       else begin
          bar_hit[0] <= #Tcq bar0_32_hit | bar01_64_hit;
          bar_hit[1] <= #Tcq bar1_32_hit;
          bar_hit[2] <= #Tcq bar2_32_hit | bar23_64_hit;
          bar_hit[3] <= #Tcq bar3_32_hit; 
          bar_hit[4] <= #Tcq bar4_32_hit | bar45_64_hit;
          bar_hit[5] <= #Tcq bar5_32_hit; 
          bar_hit[6] <= #Tcq bar6_32_hit ;
          cmmt_rbar_hit_lat2_n <= #Tcq 0;
       end
    end
    
    integer i;
    
    // keep bar_hit high for duration bewteen sof and eof 
    // that is the duration of the packet
    always @(posedge clk)
    begin
        for (i = 0; i < 7; i = i+1) begin
            if (rst == 1'b1)
                bar_hit_d[i] <= #Tcq 1'b0;        
            else if  (bar_hit[i] == 1'b1) 
                bar_hit_d[i] <= #Tcq 1'b1;
            else if (llk_rx_eof_n_d4 == 1'b0)  
                bar_hit_d[i] <= #Tcq 1'b0;  
        end        
        
    end
    
    assign bar_hit_dd = bar_hit | bar_hit_d; 
    
    
    always @(posedge clk)
    begin
    
        if (bar_hit[0] == 1'b1)
          $display ("%d", $time, ": BAR0 HIT");
        if (bar_hit[1] == 1'b1)
          $display ("%d", $time, ": BAR1 HIT");
        if (bar_hit[2] == 1'b1)
          $display ("%d", $time, ": BAR2 HIT");
        if (bar_hit[3] == 1'b1)
          $display ("%d", $time, ": BAR3 HIT");
        if (bar_hit[4] == 1'b1)
          $display ("%d", $time, ": BAR4 HIT");
        if (bar_hit[5] == 1'b1)
          $display ("%d", $time, ": BAR5 HIT");
        if (bar_hit[6] == 1'b1)
          $display ("%d", $time, ": XROM HIT");  
    end

endmodule
