//------------------------------------------------------------------------------
//
// Copyright (C) 2006, Xilinx, Inc. All Rights Reserved.
//
// This file is owned and controlled by Xilinx and must be used solely
// for design, simulation, implementation and creation of design files
// limited to Xilinx devices or technologies. Use with non-Xilinx
// devices or technologies is expressly prohibited and immediately
// terminates your license.
//
// Xilinx products are not intended for use in life support
// appliances, devices, or systems. Use in such applications is
// expressly prohibited.
//
//   ____  ____
//  /   /\/   /
// /___/  \  /    Vendor      : Xilinx
// \   \   \/     Version     : 1.3
//  \   \         Application : Generated by Xilinx PCI Express Wizard
//  /   /         Filename    : pcie_reset_logic.v
// /___/   /\     Module      : pcie_reset_logic 
// \   \  /  \
//  \___\/\___\
//
//------------------------------------------------------------------------------

`timescale 1 ns / 10 ps

module pcie_reset_logic
  (
    l0dlupdown,
    gsr,
    crmcoreclk,
    l0ltssmstate,
    crmdohotresetn,
    crmpwrsoftresetn,
    
    crmmgmtrstn,
    crmnvrstn,
    crmmacrstn,
    crmlinkrstn,
    crmurstn,
    crmusercfgrstn,
    
    user_master_reset_n,
    clock_ready
   
  );

    input       l0dlupdown;
    input       gsr;
    input       crmcoreclk;
    input [3:0] l0ltssmstate;
    input       crmdohotresetn;
    input       crmpwrsoftresetn;
    
    output      crmmgmtrstn;
    output      crmnvrstn;
    output      crmmacrstn;
    output      crmlinkrstn;
    output      crmurstn;
    output      crmusercfgrstn;
    
    input       user_master_reset_n;
    input       clock_ready;
    
    parameter G_RESETMODE     = "FALSE";
    parameter G_RESETSUBMODE  = 1;
    parameter G_USE_EXTRA_REG = 1;
    
    // Common logic for all reset mode
    
    wire   fpga_logic_reset_n;
    assign fpga_logic_reset_n = ~gsr && user_master_reset_n;
    
    // l0dlupdown[0] capture
    reg    dl_down_1, dl_down_2;
    reg    dl_down_reset_1_n, dl_down_reset_2_n;
    reg    dl_down_reset_n;

    always @ (posedge crmcoreclk, negedge fpga_logic_reset_n)
       if (!fpga_logic_reset_n) begin
            dl_down_1 <= 1'b1;
            dl_down_2 <= 1'b1;
       end else begin
            dl_down_1 <= l0dlupdown;
            dl_down_2 <= dl_down_1;
       end

    // Edge detect and pulse stretch to create dl_down_reset_n pulse
    // The pulse can be further stretched for debugging purpose by adding
    // more register stages.
    always @ (posedge crmcoreclk, negedge fpga_logic_reset_n)
       if (!fpga_logic_reset_n) begin
            dl_down_reset_1_n <= 1'b1;
            dl_down_reset_2_n <= 1'b1;
            dl_down_reset_n   <= 1'b1;
       end else begin
            dl_down_reset_1_n <= ~(~dl_down_1 & dl_down_2);
            dl_down_reset_2_n <= dl_down_reset_1_n;
            dl_down_reset_n   <= dl_down_reset_1_n && dl_down_reset_2_n;
       end
    
    // End common logic section
    
    generate 
      if (G_RESETMODE == "TRUE") begin : resetmode_true
       // 6-domain reset mode (RESETMODE=TRUE)
       
         if (G_RESETSUBMODE == 0) begin : sub_0_mode_true
           // a. user_master_reset_n is used to drive crmmgmtrstn
           assign crmmgmtrstn = clock_ready && user_master_reset_n;
           assign crmnvrstn   = 1'b1;
           assign crmmacrstn  = 1'b1;
           assign crmlinkrstn = dl_down_reset_n && crmdohotresetn;
           assign crmurstn    = dl_down_reset_n && crmdohotresetn;
           assign crmusercfgrstn = dl_down_reset_n && crmdohotresetn && crmpwrsoftresetn;
         end
       
         else begin : sub_1_mode_true
           //b. user_master_reset_n is used but does not drive crmmgmtrstn
           assign crmmgmtrstn = clock_ready;
           assign crmnvrstn   = user_master_reset_n;
           assign crmmacrstn  = user_master_reset_n;
           assign crmlinkrstn = user_master_reset_n && dl_down_reset_n && crmdohotresetn;
           assign crmurstn    = user_master_reset_n && dl_down_reset_n && crmdohotresetn;
           assign crmusercfgrstn = user_master_reset_n && dl_down_reset_n && crmdohotresetn && crmpwrsoftresetn;
         end
       
       // End 6-domain reset mode logic
      end
    endgenerate


    generate 
      if (G_RESETMODE == "FALSE") begin : resetmode_false
        // 4-domain hierarchical reset mode (RESETMODE=FALSE)
        // This mode requires decoding the l0ltssmstate outputs
        // from the PCIe block to detect LTSSM transition from Disabled
        // (1011), Loopback (1001) or Hot Reset (1010) to Detect (0001).
        wire      ltssm_linkdown_hot_reset_n;
        reg       ltssm_dl_down_last_state;
        wire [3:0] ltssm_capture = l0ltssmstate;
        reg       crmpwrsoftresetn_capture;
        reg       ltssm_linkdown_hot_reset_reg_n;
        
        // Use with G_USE_EXTRA_REG == 1 for better timing
        always @ (posedge crmcoreclk) begin
           crmpwrsoftresetn_capture       <= crmpwrsoftresetn;
           ltssm_linkdown_hot_reset_reg_n <= ltssm_linkdown_hot_reset_n;
        end
        
        always @ (posedge crmcoreclk, negedge fpga_logic_reset_n) begin
           if (G_USE_EXTRA_REG == 1) begin
              if (!fpga_logic_reset_n) begin
                   ltssm_dl_down_last_state <= 1'b0;
              end else if ((ltssm_capture == 4'b1010) || (ltssm_capture == 4'b1001) || (ltssm_capture == 4'b1011) ||
                           (ltssm_capture == 4'b1100) || (ltssm_capture == 4'b0011)) begin
                   ltssm_dl_down_last_state <= 1'b1;
              end else begin
                   ltssm_dl_down_last_state <= 1'b0;
              end
           end else begin
              if (!fpga_logic_reset_n) begin
                   ltssm_dl_down_last_state <= 1'b0;
              end else if ((l0ltssmstate == 4'b1010) || (l0ltssmstate == 4'b1001) || (l0ltssmstate == 4'b1011) ||
                           (l0ltssmstate == 4'b1100) || (l0ltssmstate == 4'b0011)) begin
                   ltssm_dl_down_last_state <= 1'b1;
              end else begin
                   ltssm_dl_down_last_state <= 1'b0;
              end
           end
        end
        
        assign ltssm_linkdown_hot_reset_n = (G_USE_EXTRA_REG == 1) ? 
             ~(ltssm_dl_down_last_state && (ltssm_capture[3:1] == 3'b000)) :
             ~(ltssm_dl_down_last_state && (l0ltssmstate[3:1] == 3'b000));
        
          if (G_RESETSUBMODE == 0) begin : sub_0_mode_false
             // a. user_master_reset_n is used to drive crmmgmtrstn
             assign crmmgmtrstn = clock_ready && user_master_reset_n;
             assign crmnvrstn   = 1'b1;
             assign crmurstn    = (G_USE_EXTRA_REG == 1) ? ltssm_linkdown_hot_reset_reg_n : ltssm_linkdown_hot_reset_n;
             assign crmusercfgrstn = (G_USE_EXTRA_REG == 1) ? crmpwrsoftresetn_capture : crmpwrsoftresetn;
             assign crmmacrstn  = 1'b1;  // not used, just avoiding 'z' in simulation
             assign crmlinkrstn = 1'b1; // not used, just avoiding 'z' in simulation
          end
        
          else begin : sub_1_mode_false
             // b. user_master_reset_n is used but does not drive crmmgmtrstn
             assign crmmgmtrstn = clock_ready;
             assign crmnvrstn   = user_master_reset_n;
             assign crmurstn    = (G_USE_EXTRA_REG == 1) ? ltssm_linkdown_hot_reset_reg_n : ltssm_linkdown_hot_reset_n;
             assign crmusercfgrstn = (G_USE_EXTRA_REG == 1) ? crmpwrsoftresetn_capture : crmpwrsoftresetn;
             assign crmmacrstn  = 1'b1;  // not used, just avoiding 'z' in simulation
             assign crmlinkrstn = 1'b1; // not used, just avoiding 'z' in simulation
          end
        
        // End 4-domain hierarchical reset mode logic
      end
    endgenerate

endmodule
